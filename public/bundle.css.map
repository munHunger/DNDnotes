{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../App.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { onMount } from \"svelte\";\n  import yaml from \"js-yaml\";\n\n  let camera = { x: 0, y: 0 };\n\n  let canvas;\n  let buffer;\n  let notes;\n  let noteFetch = window\n    .fetch(\"/notes.yml\")\n    .then(data => data.text())\n    .then(data => yaml.load(data, \"utf-8\").notes)\n    .then(notes =>\n      Promise.all(\n        notes.map(note =>\n          window\n            .fetch(note.res)\n            .then(data => data.text())\n            .then(data => yaml.load(data, \"utf-8\"))\n        )\n      )\n    )\n    .then(n => {\n      notes = n;\n      return n;\n    })\n    .then(n => document.fonts.load(\"20px Indie Flower\"))\n    .then(d => {\n      console.log(d);\n      return notes;\n    });\n\n  let ctx;\n  function render(notes) {\n    const ctx = buffer.getContext(\"2d\");\n    let boundingBox = calculateBoundingBox();\n\n    buffer.width = boundingBox.max.x - boundingBox.min.x;\n    buffer.height = boundingBox.max.y - boundingBox.min.y;\n    ctx.translate(-boundingBox.min.x, -boundingBox.min.y);\n    // ctx.fillStyle = \"#000\";\n    // ctx.fillRect(-9999, -9999, 9999 * 2, 9999 * 2);\n    notes.forEach(note => {\n      ctx.fillStyle = \"#EEE\";\n      ctx.strokeStyle = \"#AAA\";\n      ctx.translate(note.position.x, note.position.y);\n      ctx.font = \"20px Indie Flower\";\n      ctx.fillText(note.title, 0, 20);\n      ctx.font = \"16px Indie Flower\";\n      note.content\n        .filter(c => c.type === \"text\")\n        .forEach(text => {\n          text.content\n            .split(\"\\n\")\n            .forEach((line, index) =>\n              ctx.fillText(\n                line,\n                text.position.x,\n                text.position.y + 20 * 2 + 18 * index\n              )\n            );\n        });\n      note.content\n        .filter(c => c.type === \"shape\")\n        .forEach(shape => {\n          if (shape.position) ctx.translate(shape.position.x, shape.position.y);\n          shape.stroke\n            .split(\"\\n\")\n            .map(line => {\n              const [x1, y1, x2, y2, sx, sy] = line\n                .split(\" \")\n                .map(part => parseInt(part));\n              return { x1, y1, x2, y2, sx, sy };\n            })\n            .forEach(line => {\n              drawLine(line, ctx);\n            });\n          if (shape.position)\n            ctx.translate(-shape.position.x, -shape.position.y);\n        });\n      note.content\n        .filter(c => c.type === \"arrow\")\n        .forEach(arrow => {\n          let p = arrow.content.split(\" \").map(n => parseInt(n));\n          console.log(p);\n          ctx.moveTo(p[0], p[1]);\n          ctx.quadraticCurveTo(p[2], p[3], p[4], p[5]);\n          ctx.stroke();\n          drawArrowhead(\n            p[4],\n            p[5],\n            findAngle(p[2], p[3], p[4], p[5]),\n            15,\n            15,\n            ctx\n          );\n        });\n      ctx.translate(-note.position.x, -note.position.y);\n      camera = {\n        x: boundingBox.min.x + window.innerWidth / 2,\n        y: boundingBox.min.y + window.innerHeight / 2\n      };\n\n      let latest = notes[notes.length - 1];\n      camera.x -= latest.position.x;\n      camera.y -= latest.position.y;\n      renderCanvas();\n    });\n  }\n\n  function drawArrowhead(locx, locy, angle, sizex, sizey, ctx) {\n    var hx = sizex / 2;\n    var hy = sizey / 2;\n\n    ctx.translate(locx, locy);\n    ctx.rotate(angle);\n    ctx.translate(-hx, -hy);\n\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, 1 * sizey);\n    ctx.lineTo(1 * sizex, 1 * hy);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.translate(hx, hy);\n    ctx.rotate(-angle);\n    ctx.translate(-locx, -locy);\n  }\n\n  // returns radians\n  function findAngle(sx, sy, ex, ey) {\n    // make sx and sy at the zero point\n    return Math.atan2(ey - sy, ex - sx);\n  }\n\n  function drawLine(line, ctx) {\n    ctx.moveTo(line.x1, line.y1);\n    ctx.lineTo(line.x2, line.y2);\n    ctx.stroke();\n\n    let dist = Math.sqrt(\n      Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1, 2)\n    );\n    let spacing = 10;\n    let length = 5;\n    for (let i = 0; i < dist / spacing; i++) {\n      const progress = i / parseInt(dist / spacing);\n      let dx = line.x1 + (line.x2 - line.x1) * progress;\n      let dy = line.y1 + (line.y2 - line.y1) * progress;\n\n      ctx.moveTo(dx, dy);\n      ctx.lineTo(dx + length * line.sx, dy + length * line.sy);\n      ctx.stroke();\n    }\n  }\n\n  let dragging = false;\n  let prev;\n  function dragCamera(event) {\n    const [x, y] = [\n      event.x || event.touches[0].pageX,\n      event.y || event.touches[0].pageY\n    ];\n    if (dragging) {\n      camera.x += (x - prev.x) * 1;\n      camera.y += (y - prev.y) * 1;\n      renderCanvas();\n      prev = { x, y };\n    }\n  }\n\n  function renderCanvas() {\n    const ctx = canvas.getContext(\"2d\");\n    ctx.translate(camera.x, camera.y);\n    ctx.clearRect(\n      -1000,\n      -1000,\n      buffer.width * 2 + 1000,\n      buffer.height * 2 + 1000\n    );\n    ctx.drawImage(buffer, 0, 0);\n    ctx.translate(-camera.x, -camera.y);\n  }\n\n  function startDrag(event) {\n    const [x, y] = [\n      event.x || event.touches[0].pageX,\n      event.y || event.touches[0].pageY\n    ];\n    prev = { x, y };\n    dragging = true;\n  }\n\n  function stopDrag() {\n    dragging = false;\n  }\n\n  function calculateBoundingBox() {\n    let min = { x: 1, y: 1 };\n    let max = { x: -1, y: -1 };\n    notes.forEach(note => {\n      const [x1, y1, x2, y2] = note.boundingBox\n        .split(\" \")\n        .map(n => parseInt(n));\n      min = {\n        x: Math.min(min.x, note.position.x + x1),\n        y: Math.min(min.y, note.position.y + y1)\n      };\n      max = {\n        x: Math.max(max.x, note.position.x + x2),\n        y: Math.max(max.y, note.position.y + y2)\n      };\n    });\n    return { min, max };\n  }\n\n  onMount(() => {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    if (!notes) noteFetch.then(n => render(n));\n    else render(notes);\n  });\n  console.log(\n    WebFont.load({\n      google: {\n        families: [\"Indie Flower\"]\n      }\n    })\n  );\n</script>\n\n<style>\n  canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 0px;\n    top: 0px;\n    background-color: rgb(81, 87, 97);\n  }\n</style>\n\n<canvas bind:this={buffer} style=\"display:none\" />\n\n<canvas\n  bind:this={canvas}\n  on:mousedown={startDrag}\n  on:touchstart={startDrag}\n  on:mouseup={stopDrag}\n  on:touchend={stopDrag}\n  on:mousemove={dragCamera}\n  on:touchmove={dragCamera} />\n"
  ],
  "names": [],
  "mappings": "AA0OE,MAAM,cAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,CACR,gBAAgB,CAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,AACnC,CAAC"
}